# CS-255 Module Eight Journal - Melissa Chessa

## Reflection on the DriverPass Project

The DriverPass project was designed for a fictional client offering a hybrid of online and in-person driving instruction to help users better prepare for their DMV driving exams. The client, represented by Liam and Ian, wanted a web-based, cloud-hosted platform that could handle everything from lesson scheduling and package management to secure user authentication and progress tracking. The final system supports multiple roles, including students, instructors, administrators, and IT staff, each with different access levels through role-based controls.

One thing I feel I did particularly well was organizing both the functional and technical requirements of the system across documents. I paid careful attention to role responsibilities and system limitations, which helped align the design with the client’s goals and user needs. I was also proud of how I described real-world constraints like API dependencies on the DMV and the absence of full offline access, giving my work a practical and grounded scope.

If I were to revise one part of my work, I’d go back to the UML diagrams, especially the class and sequence diagrams. I think they could be improved visually and structurally to make the relationships and interactions easier to follow at a glance. More consistent formatting and clearer actor/system separation would help make them more readable to both technical and non-technical stakeholders.

Interpreting the user’s needs meant breaking down their frustrations with current systems and translating that into secure, simple-to-use features. I focused heavily on the end users—like students needing access to practice tests and lesson feedback—and built out role-specific interactions based on what each user would realistically need. This user-centered approach helped ensure that every feature tied back to a specific purpose. Considering user needs is crucial because if the system doesn’t work for the people using it, it doesn’t matter how clean the backend code is.

When designing software, I usually start by breaking the system into parts of what the system needs to do (functional), how fast and secure it should be (non-functional), and how users interact with it (UI/UX). I use models like use case diagrams to map this out. In the future, I’ll keep relying on clear modeling tools like Lucidchart, but I also want to refine how I organize my design documents and make sure every diagram communicates purpose, not just structure.

This project helped me understand the importance of aligning technical requirements with real-world expectations and how to document both system needs and limitations so developers and clients stay on the same page.
